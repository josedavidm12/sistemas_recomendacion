# -*- coding: utf-8 -*-
"""funciones.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zPFn8QbkjpN0-oTmd9qG-5_ubD0xyKFt
"""

# Librerías estándar de Python
import os  
import sys

# Librerías de manejo de datos
import numpy as np
import pandas as pd

# Librerías de conexión a bases de datos
import sqlite3 as sql

# Librerías de visualización
import matplotlib.pyplot as plt  
import seaborn as sns  
import plotly.graph_objs as go  
import plotly.express as px  
from plotly.subplots import make_subplots  

# Librerías de estadísticas y machine learning
import scipy.stats as stats
from scipy.stats import gaussian_kde  
from sklearn.decomposition import PCA  
from sklearn.preprocessing import StandardScaler  

# Librerías de soporte para Google Colab
from google.colab import drive  
from google.colab import files  

# Librerías auxiliares
from collections import Counter  



### Funciones ###


#Muestra información básica y estadísticas descriptivas de un DataFrame.
#Parámetros:
#df: pd.DataFrame - El DataFrame a explorar.
#nombre_df: str - Nombre opcional del DataFrame para mostrar en los títulos.
def explorar_dataframe(df, nombre_df="DataFrame"):

    print(f"# Algunos datos a conocer de la tabla {nombre_df}")
    print(f"Dimensiones: {df.shape[0]} filas y {df.shape[1]} columnas")
    print("*" * 50)
    print("\nDescripción de los datos:")
    print(df.info())
    print("*" * 50)
    print("\nEstadísticas descriptivas:")
    print(df.describe(include='all'))


#Esta función ejecuta un script SQL completo desde un archivo.
def ejecutar_sql (nombre_archivo, cur):
    sql_file=open(nombre_archivo)
    sql_as_string=sql_file.read()
    sql_file.close
    cur.executescript(sql_as_string)



#Función que genera visualizaciones para detectar outliers (valores atípicos)
#en las variables numéricas de un DataFrame
def visual_outliers(df):    
    # Seleccionar columnas numéricas y excluir las de géneros
    numeric_cols = df.select_dtypes(include='float64').columns

    df_comparison = pd.DataFrame()
    for col in numeric_cols:
        df_comparison[f'{col}_original'] = df[col]

    num_vars = len(numeric_cols)
    n_cols = 2
    n_rows = (num_vars + n_cols - 1) // n_cols

    # Boxplots
    plt.figure(figsize=(12, 5 * n_rows))
    for i, col in enumerate(numeric_cols):
        plt.subplot(n_rows, n_cols, i + 1)
        sns.boxplot(data=df_comparison[[f'{col}_original']])
        plt.title(f'Boxplot de {col} Original', fontsize=14)
        plt.xticks([0], ['Original'], fontsize=12)
        plt.xlabel('')
        plt.ylabel('Valor', fontsize=12)

    plt.tight_layout()
    plt.show()

    # Histogramas con KDE
    fig_hist = make_subplots(n_rows, n_cols, subplot_titles=[f'Histograma {column}' for column in numeric_cols], shared_yaxes=True)
    for i, column in enumerate(numeric_cols):
        hist = go.Histogram(x=df[column], name=f'Histograma {column}', nbinsx=30, opacity=0.75,
                            marker=dict(color='blue', line=dict(color='black', width=1)))
        fig_hist.add_trace(hist, row=(i // n_cols) + 1, col=(i % n_cols) + 1)

        kde = gaussian_kde(df[column], bw_method='scott')
        x = np.linspace(df[column].min(), df[column].max(), 1000)
        p = kde(x)
        hist_values, bin_edges = np.histogram(df[column], bins=30)
        kde_scaled = p * np.max(hist_values) / np.max(p)

        fig_hist.add_trace(go.Scatter(x=x, y=kde_scaled, mode='lines', name=f'KDE {column}',
                                      line=dict(color='red')), row=(i // n_cols) + 1, col=(i % n_cols) + 1)

    fig_hist.update_layout(height=300 * n_rows, width=800, title_text="Histogramas variables numéricas con KDE")
    fig_hist.show()



#Función que cuenta el número de outliers (valores atípicos) para cada variable numérica
#en un DataFrame, utilizando el método del rango intercuartílico (IQR).
#Retorna un DataFrame con el nombre de la variable y la cantidad de outliers encontrados.
def contar_outliers_iqr(df):
    numeric_cols = df.select_dtypes(include='float64').columns
    outliers_count = {
        col: ((df[col] < df[col].quantile(0.25) - 1.5 * (df[col].quantile(0.75) - df[col].quantile(0.25))) |
              (df[col] > df[col].quantile(0.75) + 1.5 * (df[col].quantile(0.75) - df[col].quantile(0.25)))).sum()
        for col in numeric_cols
    }
    return pd.DataFrame(list(outliers_count.items()), columns=['Variable', 'Cantidad de Atípicos'])



#Imputa los valores atípicos de una columna con la media de la columna.
#Args:
#df: DataFrame de pandas.
#column: Nombre de la columna a imputar.
def impute_outliers_with_mean(df, column):
    numeric_cols = df.select_dtypes(include='float64').columns

    if column not in numeric_cols:
        print(f"La columna '{column}' no es numérica.")
        return df

    col_data = df[column].dropna()

    # Calcular IQR
    Q1 = col_data.quantile(0.25)
    Q3 = col_data.quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR

    # Identificar y reemplazar los valores atípicos con la media
    mean_value = col_data.mean()
    df.loc[(df[column] < lower_bound) | (df[column] > upper_bound), column] = mean_value
    return df